// Copyright Epic Games, Inc. All Rights Reserved.
// This source file is licensed solely to users who have
// accepted a valid Unreal Engine license agreement 
// (see e.g., https://www.unrealengine.com/eula), and use
// of this source file is governed by such agreement.

// This file was generated by sketchy. DO NOT EDIT!
// Scheduling model: Cortex-A53
// vim:ts=4

#include "asmlib_arm_a64.inc"

		.text
		.globl MANGLE(oodle_newLZ_huff3_a64_kern)
		.align 4
		FUNCTION_PRE_DECL(oodle_newLZ_huff3_a64_kern)
MANGLE(oodle_newLZ_huff3_a64_kern):
		.cfi_startproc
.L0:
		ldp		x2, x5, [x0, #48]
		mov		x3, #0
		ldr		x8, [x0, #64]
		mov		x6, #0
		ldr		x11, [x0]
		mov		x9, #0
		ldr		x13, [x0, #16]
		sub		x7, x5, x8								// in1 - in2
		mov		x12, #0
		sub		x13, x13, x11							// nbytesleft = decend0 - decptr[0]
		subs	xzr, x13, #15
		b.ls	.L1										// -> return true
.L4:
		subs	xzr, x7, #8
		b.ls	.L1										// -> return true
.L5:
		sub		x13, x13, #15
		sub		x5, x5, #8
		sub		x11, x11, #3
		.align	4
.L6: // Main decode loop body
		ldr		x7, [x5]								// refill 1 load
		and		x9, x9, #7								// refill 2 leftover bits
		ldr		x10, [x8]								// refill 2 load
		and		x3, x3, #7								// refill 0 leftover bits
		ldr		x4, [x2]								// refill 0 load
		and		x6, x6, #7								// refill 1 leftover bits
		rev		x7, x7									// refill 1 LE->BE
		orr		x10, x10, #0x8000000000000000			// refill 2 mark
		orr		x7, x7, #0x8000000000000000				// refill 1 mark
		lsrv	x9, x10, x9								// refill 2 consume leftover
		orr		x4, x4, #0x8000000000000000				// refill 0 mark
		lsrv	x6, x7, x6								// refill 1 consume leftover
		lsrv	x3, x4, x3								// refill 0 consume leftover
		ubfm	x10, x9, #63, #10						// decode 2 tab addr
		ubfm	x7, x6, #63, #10						// decode 1 tab addr
		ubfm	x4, x3, #63, #10						// decode 0 tab addr
		prfum	#1, [x2, #39]							// refill 0 prefetch
		subs	x13, x13, #15							// (nbytesleft -= TRIPLE_DECS_PER_REFILL) > 0
		ldrh	w10, [x1, x10]							// decode 2 LUT
		ldrh	w7, [x1, x7]							// decode 1 LUT
		ldrh	w4, [x1, x4]							// decode 0 LUT
		lsrv	x9, x9, x10								// decode 2 consume
		rev32	x12, x10								// out 0 byte 2
		orr		x12, x12, x7							// out 0 byte 1
		ubfm	x10, x9, #63, #10						// decode 2 tab addr
		lsrv	x6, x6, x7								// decode 1 consume
		bfm		x12, x4, #8, #15						// out 0 byte 0
		lsrv	x3, x3, x4								// decode 0 consume
		ubfm	x7, x6, #63, #10						// decode 1 tab addr
		ldrh	w10, [x1, x10]							// decode 2 LUT
		ubfm	x4, x3, #63, #10						// decode 0 tab addr
		str		w12, [x11, #3]							// out 0 emit
		ldrh	w7, [x1, x7]							// decode 1 LUT
		ldrh	w4, [x1, x4]							// decode 0 LUT
		lsrv	x9, x9, x10								// decode 2 consume
		rev32	x12, x10								// out 0 byte 2
		ubfm	x10, x9, #63, #10						// decode 2 tab addr
		lsrv	x6, x6, x7								// decode 1 consume
		orr		x12, x12, x7							// out 0 byte 1
		lsrv	x3, x3, x4								// decode 0 consume
		ubfm	x7, x6, #63, #10						// decode 1 tab addr
		ldrh	w10, [x1, x10]							// decode 2 LUT
		bfm		x12, x4, #8, #15						// out 0 byte 0
		ubfm	x4, x3, #63, #10						// decode 0 tab addr
		str		w12, [x11, #6]							// out 0 emit
		ldrh	w7, [x1, x7]							// decode 1 LUT
		lsrv	x9, x9, x10								// decode 2 consume
		rev32	x12, x10								// out 0 byte 2
		ldrh	w4, [x1, x4]							// decode 0 LUT
		orr		x12, x12, x7							// out 0 byte 1
		lsrv	x6, x6, x7								// decode 1 consume
		ubfm	x10, x9, #63, #10						// decode 2 tab addr
		ubfm	x7, x6, #63, #10						// decode 1 tab addr
		prfum	#1, [x5, #-32]							// refill 1 prefetch
		lsrv	x3, x3, x4								// decode 0 consume
		bfm		x12, x4, #8, #15						// out 0 byte 0
		ldrh	w10, [x1, x10]							// decode 2 LUT
		ubfm	x4, x3, #63, #10						// decode 0 tab addr
		ldrh	w7, [x1, x7]							// decode 1 LUT
		str		w12, [x11, #9]							// out 0 emit
		ldrh	w4, [x1, x4]							// decode 0 LUT
		rev32	x12, x10								// out 0 byte 2
		orr		x12, x12, x7							// out 0 byte 1
		lsrv	x6, x6, x7								// decode 1 consume
		lsrv	x9, x9, x10								// decode 2 consume
		ubfm	x7, x6, #63, #10						// decode 1 tab addr
		lsrv	x3, x3, x4								// decode 0 consume
		bfm		x12, x4, #8, #15						// out 0 byte 0
		ubfm	x4, x3, #63, #10						// decode 0 tab addr
		ubfm	x10, x9, #63, #10						// decode 2 tab addr
		ldrh	w7, [x1, x7]							// decode 1 LUT
		clz		x3, x3									// decode 0 pre-final consume count
		clz		x6, x6									// decode 1 pre-final consume count
		clz		x9, x9									// decode 2 pre-final consume count
		ldrh	w4, [x1, x4]							// decode 0 LUT
		ldrh	w10, [x1, x10]							// decode 2 LUT
		add		x6, x6, w7, uxtb #0						// decode 1 final consume count
		str		w12, [x11, #12]							// out 0 emit
		add		x3, x3, w4, uxtb #0						// decode 0 final consume count
		sub		x5, x5, x6, lsr #3						// advance 1
		add		x9, x9, w10, uxtb #0					// decode 2 final consume count
		rev32	x12, x10								// out 0 byte 2
		add		x2, x2, x3, lsr #3						// advance 0
		orr		x12, x12, x7							// out 0 byte 1
		prfum	#1, [x8, #39]							// refill 2 prefetch
		add		x8, x8, x9, lsr #3						// advance 2
		ccmp	x2, x8, #2, gt							// && in0 <= in2
		ccmp	x8, x5, #2, ls							// && in2 <= in1
		bfm		x12, x4, #8, #15						// out 0 byte 0
		str		w12, [x11, #15]!						// out 0 emit
		b.ls	.L6										// -> Main decode loop body
.L7: // Post-decode
		add		x5, x5, #8
		add		x11, x11, #3
		and		x3, x3, #7
		and		x6, x6, #7
		and		x9, x9, #7
		str		x11, [x0]
		subs	xzr, x2, x8
		b.hi	.L3										// -> return false
.L8:
		subs	xzr, x8, x5
		b.hi	.L3										// -> return false
.L9:
		subs	xzr, x5, x8
		ccmn	x6, x9, #4, eq							// inptr[1] == inptr[2] && (bits[1] + bits[2]) != 0?
		b.ne	.L3										// -> return false
.L10: // Finish stream 0
		cbz		x3, .L11								// -> Finish stream 1
.L12:
		ldrb	w4, [x2], #1
		mov		x7, #8
		sub		x7, x7, x3
		lsrv	x4, x4, x3
		str		w4, [x0, #96]
		str		w7, [x0, #120]
.L11: // Finish stream 1
		str		x2, [x0, #48]
		cbz		x6, .L13								// -> Finish stream 2
.L14:
		ldrb	w4, [x5, #-1]!
		mov		x7, #8
		sub		x7, x7, x6
		lsrv	x4, x4, x6
		str		w4, [x0, #100]
		str		w7, [x0, #124]
.L13: // Finish stream 2
		str		x5, [x0, #56]
		cbz		x9, .L15
.L16:
		ldrb	w4, [x8], #1
		mov		x7, #8
		sub		x7, x7, x9
		lsrv	x4, x4, x9
		str		w4, [x0, #104]
		str		w7, [x0, #128]
.L15:
		str		x8, [x0, #64]
.L1: // return true
		mov		x0, #1									// return val=true
.L2: // exit
		ret		
.L3: // return false
		mov		x0, #0									// return val=false
		b		.L2										// -> exit
		FUNCTION_POST_DECL(oodle_newLZ_huff3_a64_kern)
		.cfi_endproc
