// Copyright Epic Games, Inc. All Rights Reserved.
// This source file is licensed solely to users who have
// accepted a valid Unreal Engine license agreement 
// (see e.g., https://www.unrealengine.com/eula), and use
// of this source file is governed by such agreement.

// This file was generated by sketchy. DO NOT EDIT!
// Scheduling model: Cortex-A53
// vim:ts=4

#include "asmlib_arm_a64.inc"

		.text
		.globl MANGLE(oodle_decode_offsetalt_a64_kern)
		.align 4
		FUNCTION_PRE_DECL(oodle_decode_offsetalt_a64_kern)
MANGLE(oodle_decode_offsetalt_a64_kern):
		.cfi_startproc
.L0:
		ldp		x2, x3, [x0]							// offs_u8/offs_u8_end
		ldp		x4, x13, [x0, #16]						// neg_offs_s32/bitp0
		ldr		x17, [x0, #32]							// bitp1
		stp		x19, x20, [sp, #-64]!
		ldp		w14, w19, [x0, #40]						// bitc0/bitc1
		stp		x21, x22, [sp, #16]
		sub		x21, x3, x2
		stp		x23, x24, [sp, #32]
		subs	xzr, x21, #8							// offs_u8_end - offs_u8 >= 8
		stp		x25, x26, [sp, #48]
		sub		x22, x17, x13
		ccmp	x22, #8, #0, cs							// && bitp1 - bitp0 >= 8
		b.cc	.L2										// -> Success
.L4:
		mov		x6, #0x8080808080808080
		sub		x3, x3, #7								// offs_u8_end -= 7
		ubfm	x6, x6, #16, #63
		sub		x17, x17, #8							// bitp[1] -= 8
		sub		x2, x2, x3								// offs_u8 -= offs_u8_end
		sub		x4, x4, #8								// neg_offs_s32 -= 2 (8B)
		mov		x7, #0x1f1f1f1f1f1f1f1f
		mov		x9, #0x5555555555555555
		eor		x9, x9, #0x3030303030303030
		eor		x8, x9, #0x808080808080808
		mov		x10, #38
		.align	4
.L5: // Main decode loop head
		ldr		x5, [x3, x2]							// grab next 8 offs_U8
		and		x14, x14, #7							// stream 0 leftover bitcnt
		ldr		x12, [x13]								// stream 0 load bits
		and		x19, x19, #7							// stream 1 leftover bitcnt
		ldr		x16, [x17]								// stream 1 load bits
		and		x21, x7, x5, lsr #3						// numraw for 8 offsets
		prfum	#1, [x13, #71]							// stream 0 prefetch
		add		x22, x21, x8							// MSB in byte set iff numraw >=19
		sub		x11, x6, x21							// 128-numraw per byte
		ands	xzr, x22, x6							// MSB set for any of next 6 offsets?
		rev		x12, x12								// stream 0 LE->BE
		prfum	#1, [x17, #-64]							// stream 1 prefetch
		b.ne	.L7										// -> Large offsets present
.L6: // All numraws <=18
		sbfm	x23, x11, #0, #6						// offs 0 neg_num_raw
		sbfm	x24, x11, #8, #14						// offs 1 neg_num_raw
		ubfm	x21, x5, #0, #7							// offs 0 U8
		ubfm	x22, x5, #8, #15						// offs 1 U8
		and		x25, x12, x23, asr #63					// offs 0 handle num_raw=0
		and		x26, x16, x24, asr #63					// offs 1 handle num_raw=0
		adds	x2, x2, #6								// advance offs_U8 ptr (carry if done)
		ldr		w21, [x1, x21, lsl #2]					// offs 0 bias
		lslv	x25, x25, x14							// offs 0 consume bits
		ldr		w22, [x1, x22, lsl #2]					// offs 1 bias
		lslv	x26, x26, x19							// offs 1 consume bits
		lsrv	x25, x25, x23							// offs 0 extract bits
		sub		x14, x14, x23							// offs 0 update bitcnt
		lsrv	x26, x26, x24							// offs 1 extract bits
		sbfm	x23, x11, #16, #22						// offs 2 neg_num_raw
		sub		x19, x19, x24							// offs 1 update bitcnt
		sbfm	x24, x11, #24, #30						// offs 3 neg_num_raw
		sub		w15, w21, w25							// offs 0 finalize offset
		sub		w20, w22, w26							// offs 1 finalize offset
		ubfm	x21, x5, #16, #23						// offs 2 U8
		ubfm	x22, x5, #24, #31						// offs 3 U8
		and		x25, x12, x23, asr #63					// offs 2 handle num_raw=0
		and		x26, x16, x24, asr #63					// offs 3 handle num_raw=0
		stp		w15, w20, [x4, #8]						// emit offset pair
		ldr		w21, [x1, x21, lsl #2]					// offs 2 bias
		lslv	x25, x25, x14							// offs 2 consume bits
		ldr		w22, [x1, x22, lsl #2]					// offs 3 bias
		lslv	x26, x26, x19							// offs 3 consume bits
		lsrv	x25, x25, x23							// offs 2 extract bits
		sub		x14, x14, x23							// offs 2 update bitcnt
		lsrv	x26, x26, x24							// offs 3 extract bits
		sbfm	x23, x11, #32, #38						// offs 4 neg_num_raw
		sub		x19, x19, x24							// offs 3 update bitcnt
		sbfm	x24, x11, #40, #46						// offs 5 neg_num_raw
		sub		w15, w21, w25							// offs 2 finalize offset
		sub		w20, w22, w26							// offs 3 finalize offset
		ubfm	x21, x5, #32, #39						// offs 4 U8
		ubfm	x22, x5, #40, #47						// offs 5 U8
		and		x25, x12, x23, asr #63					// offs 4 handle num_raw=0
		and		x26, x16, x24, asr #63					// offs 5 handle num_raw=0
		stp		w15, w20, [x4, #16]						// emit offset pair
		ldr		w21, [x1, x21, lsl #2]					// offs 4 bias
		lslv	x25, x25, x14							// offs 4 consume bits
		ldr		w22, [x1, x22, lsl #2]					// offs 5 bias
		sub		x14, x14, x23							// offs 4 update bitcnt
		lslv	x26, x26, x19							// offs 5 consume bits
		sub		x19, x19, x24							// offs 5 update bitcnt
		add		x13, x13, x14, lsr #3					// advance bitp0
		sub		x17, x17, x19, lsr #3					// advance bitp1
		lsrv	x25, x25, x23							// offs 4 extract bits
		sub		w15, w21, w25							// offs 4 finalize offset
		lsrv	x26, x26, x24							// offs 5 extract bits
		sub		w20, w22, w26							// offs 5 finalize offset
		ccmp	x13, x17, #2, cc						// not done and pointers not crossed
		stp		w15, w20, [x4, #24]!					// emit offset pair
		b.ls	.L5										// -> Main decode loop head
.L9:
		b		.L8										// -> Main loop done
.L7: // Large offsets present
		add		x21, x21, x9							// MSB in byte set iff numraw too large
		ands	xzr, x21, x6							// numraw too large?
		b.ne	.L3										// -> Fail
.L10:
		ubfm	x21, x5, #0, #7							// offs 0 U8
		sbfm	x23, x11, #0, #6						// offs 0 neg_num_raw
		ubfm	x22, x5, #8, #15						// offs 1 U8
		sbfm	x24, x11, #8, #14						// offs 1 neg_num_raw
		and		x25, x12, x23, asr #63					// offs 0 handle num_raw=0
		ldr		w21, [x1, x21, lsl #2]					// offs 0 bias
		and		x26, x16, x24, asr #63					// offs 1 handle num_raw=0
		ldr		w22, [x1, x22, lsl #2]					// offs 1 bias
		lslv	x25, x25, x14							// offs 0 consume bits
		lslv	x26, x26, x19							// offs 1 consume bits
		sub		x14, x14, x23							// offs 0 update bitcnt
		lsrv	x25, x25, x23							// offs 0 extract bits
		sub		w15, w21, w25							// offs 0 finalize offset
		lsrv	x26, x26, x24							// offs 1 extract bits
		sub		w20, w22, w26							// offs 1 finalize offset
		stp		w15, w20, [x4, #8]						// emit offset pair
		sub		x19, x19, x24							// offs 1 update bitcnt
		subs	xzr, x14, x10							// bitc0 too large?
		ccmp	x19, x10, #2, ls						// or bitc1 too large?
		b.hi	.L11									// -> out of bits after 2 offsets
.L12:
		ubfm	x21, x5, #16, #23						// offs 2 U8
		sbfm	x23, x11, #16, #22						// offs 2 neg_num_raw
		ubfm	x22, x5, #24, #31						// offs 3 U8
		sbfm	x24, x11, #24, #30						// offs 3 neg_num_raw
		and		x25, x12, x23, asr #63					// offs 2 handle num_raw=0
		ldr		w21, [x1, x21, lsl #2]					// offs 2 bias
		and		x26, x16, x24, asr #63					// offs 3 handle num_raw=0
		ldr		w22, [x1, x22, lsl #2]					// offs 3 bias
		lslv	x25, x25, x14							// offs 2 consume bits
		lslv	x26, x26, x19							// offs 3 consume bits
		sub		x14, x14, x23							// offs 2 update bitcnt
		lsrv	x25, x25, x23							// offs 2 extract bits
		sub		w15, w21, w25							// offs 2 finalize offset
		lsrv	x26, x26, x24							// offs 3 extract bits
		sub		w20, w22, w26							// offs 3 finalize offset
		stp		w15, w20, [x4, #16]						// emit offset pair
		sub		x19, x19, x24							// offs 3 update bitcnt
		subs	xzr, x14, x10							// bitc0 too large?
		ccmp	x19, x10, #2, ls						// or bitc1 too large?
		b.hi	.L14									// -> out of bits after 4 offsets
.L15:
		sbfm	x23, x11, #32, #38						// offs 4 neg_num_raw
		sbfm	x24, x11, #40, #46						// offs 5 neg_num_raw
		ubfm	x21, x5, #32, #39						// offs 4 U8
		ubfm	x22, x5, #40, #47						// offs 5 U8
		and		x25, x12, x23, asr #63					// offs 4 handle num_raw=0
		and		x26, x16, x24, asr #63					// offs 5 handle num_raw=0
		adds	x2, x2, #6								// advance offs_U8 ptr (carry if done)
		ldr		w21, [x1, x21, lsl #2]					// offs 4 bias
		lslv	x25, x25, x14							// offs 4 consume bits
		ldr		w22, [x1, x22, lsl #2]					// offs 5 bias
		sub		x14, x14, x23							// offs 4 update bitcnt
		lslv	x26, x26, x19							// offs 5 consume bits
		sub		x19, x19, x24							// offs 5 update bitcnt
		add		x13, x13, x14, lsr #3					// advance bitp0
		sub		x17, x17, x19, lsr #3					// advance bitp1
		ccmp	x13, x17, #2, cc						// not done and pointers not crossed
		lsrv	x25, x25, x23							// offs 4 extract bits
		sub		w15, w21, w25							// offs 4 finalize offset
		lsrv	x26, x26, x24							// offs 5 extract bits
		sub		w20, w22, w26							// offs 5 finalize offset
		stp		w15, w20, [x4, #24]!					// emit offset pair
		b.ls	.L5										// -> Main decode loop head
.L17:
		b		.L8										// -> Main loop done
.L11: // out of bits after 2 offsets
		add		x13, x13, x14, lsr #3					// advance bitp0
		sub		x17, x17, x19, lsr #3					// advance bitp1
		add		x4, x4, #8								// neg_offs_s32 advance
		adds	x2, x2, #2								// advance offs_U8 ptr (carry if done)
		ccmp	x13, x17, #2, cc						// not done and pointers not crossed
		b.ls	.L5										// -> Main decode loop head
.L13:
		b		.L8										// -> Main loop done
.L14: // out of bits after 4 offsets
		add		x13, x13, x14, lsr #3					// advance bitp0
		sub		x17, x17, x19, lsr #3					// advance bitp1
		add		x4, x4, #16								// neg_offs_s32 advance
		adds	x2, x2, #4								// advance offs_U8 ptr (carry if done)
		ccmp	x13, x17, #2, cc						// not done and pointers not crossed
		b.ls	.L5										// -> Main decode loop head
.L16:
		b		.L8										// -> Main loop done
.L8: // Main loop done
		add		x2, x2, x3								// make offs_u8 absolute again
		add		x4, x4, #8								// undo neg_offs_s32 bias
		add		x17, x17, #8							// undo bitp1 bias
		and		x14, x14, #7							// bitc0 final
		and		x19, x19, #7							// bitc1 final
		str		x2, [x0]
		str		x4, [x0, #16]
		stp		x13, x17, [x0, #24]						// bitp0 / bitp1
		stp		w14, w19, [x0, #40]						// bitc0 / bitc1
.L2: // Success
		mov		x0, #1
.L1:
		ldp		x25, x26, [sp, #48]
		ldp		x23, x24, [sp, #32]
		ldp		x21, x22, [sp, #16]
		ldp		x19, x20, [sp], #64
		ret		
.L3: // Fail
		mov		x0, #0
		b		.L1
		FUNCTION_POST_DECL(oodle_decode_offsetalt_a64_kern)
		.cfi_endproc
