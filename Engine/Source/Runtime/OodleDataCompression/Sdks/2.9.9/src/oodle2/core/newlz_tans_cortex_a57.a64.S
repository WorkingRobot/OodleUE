// Copyright Epic Games, Inc. All Rights Reserved.
// This source file is licensed solely to users who have
// accepted a valid Unreal Engine license agreement 
// (see e.g., https://www.unrealengine.com/eula), and use
// of this source file is governed by such agreement.

// This file was generated by sketchy. DO NOT EDIT!
// Scheduling model: Cortex-A57
// vim:ts=4

#include "asmlib_arm_a64.inc"

		.text
		.globl MANGLE(oodle_newLZ_tans_a64_kern)
		.align 4
		FUNCTION_PRE_DECL(oodle_newLZ_tans_a64_kern)
MANGLE(oodle_newLZ_tans_a64_kern):
		.cfi_startproc
.L0:
		ldr		x2, [x0, #8]
		stp		x19, x20, [sp, #-64]!
		ldr		x3, [x0, #16]
		stp		x21, x22, [sp, #16]
		stp		x23, x24, [sp, #32]
		str		x25, [sp, #48]
		sub		x3, x3, x2								// nbytesleft = decend - decptr
		subs	xzr, x3, #9
		b.ls	.L1										// -> return true
.L2:
		ldp		x4, x7, [x0, #24]
		sub		x12, x7, x4								// in1 - in0
		subs	xzr, x12, #15
		b.cc	.L1										// -> return true
.L3:
		ldr		w12, [x0, #48]
		sub		x3, x3, #9
		sub		x7, x7, #15
		ldr		x1, [x0]								// table ptr
		sub		x2, x2, #1
		ldp		w10, w13, [x0, #56]
		ldp		w16, w20, [x0, #64]
		ldr		w23, [x0, #72]
		subs	w12, wzr, w12
		b.eq	.L4
.L5:
		sub		x4, x4, #1
		add		w12, w12, #8
.L4:
		ldr		x5, [x4]								// Initial bits 0
		orr		x5, x5, #0x8000000000000000				// mark
		lsrv	x5, x5, x12								// consume partial
		ldr		w12, [x0, #52]
		subs	w12, wzr, w12
		b.eq	.L6
.L7:
		add		x7, x7, #1
		add		w12, w12, #8
.L6:
		ldr		x8, [x7, #7]							// Initial bits 1
		ldr		x11, [x1, x10, lsl #3]					// TANS 0 table pre-load
		ldr		x14, [x1, x13, lsl #3]					// TANS 1 table pre-load
		ldr		x17, [x1, x16, lsl #3]					// TANS 2 table pre-load
		ldr		x21, [x1, x20, lsl #3]					// TANS 3 table pre-load
		rev		x8, x8									// backwards stream
		ldr		x24, [x1, x23, lsl #3]					// TANS 4 table pre-load
		orr		x8, x8, #0x8000000000000000				// mark
		lsrv	x8, x8, x12								// consume partial
.L8:
		subs	xzr, x4, x7
		b.hi	.L9										// -> Post-decode
		.align	4
.L10: // Main decode loop body
		ubfm	x12, x11, #32, #63						// TANS 0 len/sym/nextst
		and		w10, w5, w11							// TANS 0 masked bits
		prfum	#1, [x7, #-128]							// advance 1 prefetch
		lsrv	x5, x5, x12								// TANS 0 consume bits
		ubfm	x15, x14, #32, #63						// TANS 1 len/sym/nextst
		add		x10, x10, x11, lsr #48					// TANS 0 add next_st
		and		w13, w5, w14							// TANS 1 masked bits
		lsrv	x5, x5, x15								// TANS 1 consume bits
		prfum	#1, [x4, #135]							// advance 0 prefetch
		ldr		x11, [x1, x10, lsl #3]					// TANS 0 table pre-load
		ubfm	x19, x17, #32, #63						// TANS 2 len/sym/nextst
		add		x13, x13, x14, lsr #48					// TANS 1 add next_st
		and		w16, w5, w17							// TANS 2 masked bits
		lsrv	x5, x5, x19								// TANS 2 consume bits
		ldr		x14, [x1, x13, lsl #3]					// TANS 1 table pre-load
		ubfm	x22, x21, #32, #63						// TANS 3 len/sym/nextst
		add		x16, x16, x17, lsr #48					// TANS 2 add next_st
		and		w20, w5, w21							// TANS 3 masked bits
		lsrv	x5, x5, x22								// TANS 3 consume bits
		ldr		x17, [x1, x16, lsl #3]					// TANS 2 table pre-load
		add		x20, x20, x21, lsr #48					// TANS 3 add next_st
		and		w23, w5, w24							// TANS 4 masked bits
		add		x23, x23, x24, lsr #48					// TANS 4 add next_st
		rev16	w12, w12								// TANS 0 sym->low byte
		rev16	w15, w15								// TANS 1 sym->low byte
		ldr		x21, [x1, x20, lsl #3]					// TANS 3 table pre-load
		strb	w12, [x2, #1]							// TANS 0 emit
		ubfm	x12, x11, #32, #63						// TANS 0 len/sym/nextst
		ubfm	x25, x24, #32, #63						// TANS 4 len/sym/nextst
		ldr		x24, [x1, x23, lsl #3]					// TANS 4 table pre-load
		and		w10, w8, w11							// TANS 0 masked bits
		lsrv	x8, x8, x12								// TANS 0 consume bits
		strb	w15, [x2, #2]							// TANS 1 emit
		ubfm	x15, x14, #32, #63						// TANS 1 len/sym/nextst
		rev16	w19, w19								// TANS 2 sym->low byte
		and		w13, w8, w14							// TANS 1 masked bits
		add		x10, x10, x11, lsr #48					// TANS 0 add next_st
		strb	w19, [x2, #3]							// TANS 2 emit
		ubfm	x19, x17, #32, #63						// TANS 2 len/sym/nextst
		rev16	w22, w22								// TANS 3 sym->low byte
		ldr		x11, [x1, x10, lsl #3]					// TANS 0 table pre-load
		lsrv	x8, x8, x15								// TANS 1 consume bits
		strb	w22, [x2, #4]							// TANS 3 emit
		ubfm	x22, x21, #32, #63						// TANS 3 len/sym/nextst
		and		w16, w8, w17							// TANS 2 masked bits
		add		x13, x13, x14, lsr #48					// TANS 1 add next_st
		lsrv	x5, x5, x25								// TANS 4 consume bits
		rev16	w25, w25								// TANS 4 sym->low byte
		add		x16, x16, x17, lsr #48					// TANS 2 add next_st
		ldr		x14, [x1, x13, lsl #3]					// TANS 1 table pre-load
		lsrv	x8, x8, x19								// TANS 2 consume bits
		strb	w25, [x2, #5]							// TANS 4 emit
		ldr		x17, [x1, x16, lsl #3]					// TANS 2 table pre-load
		ubfm	x25, x24, #32, #63						// TANS 4 len/sym/nextst
		and		w20, w8, w21							// TANS 3 masked bits
		lsrv	x8, x8, x22								// TANS 3 consume bits
		clz		x5, x5									// advance 0
		add		x20, x20, x21, lsr #48					// TANS 3 add next_st
		and		w23, w8, w24							// TANS 4 masked bits
		lsrv	x8, x8, x25								// TANS 4 consume bits
		add		x4, x4, x5, lsr #3						// advance 0
		ldr		x21, [x1, x20, lsl #3]					// TANS 3 table pre-load
		clz		x8, x8									// advance 1
		add		x23, x23, x24, lsr #48					// TANS 4 add next_st
		ldr		x6, [x4]								// advance 0 load
		sub		x7, x7, x8, lsr #3						// advance 1
		and		x5, x5, #7								// advance 0 leftover bits
		ldr		x24, [x1, x23, lsl #3]					// TANS 4 table pre-load
		and		x8, x8, #7								// advance 1 leftover bits
		rev16	w12, w12								// TANS 0 sym->low byte
		ldr		x9, [x7, #7]							// advance 1 load
		rev16	w15, w15								// TANS 1 sym->low byte
		rev16	w19, w19								// TANS 2 sym->low byte
		rev16	w22, w22								// TANS 3 sym->low byte
		rev16	w25, w25								// TANS 4 sym->low byte
		strb	w12, [x2, #6]							// TANS 0 emit
		orr		x6, x6, #0x8000000000000000				// advance 0 mark
		subs	x3, x3, #10								// (nbytesleft -= TANS_DECS_PER_ITER) > 0
		strb	w15, [x2, #7]							// TANS 1 emit
		lsrv	x5, x6, x5								// advance 0 consume leftover
		ccmp	x4, x7, #2, gt							// && in0 <= in1
		strb	w19, [x2, #8]							// TANS 2 emit
		rev		x9, x9									// advance 1 LE->BE
		strb	w22, [x2, #9]							// TANS 3 emit
		orr		x9, x9, #0x8000000000000000				// advance 1 mark
		strb	w25, [x2, #10]!							// TANS 4 emit
		lsrv	x8, x9, x8								// advance 1 consume leftover
		b.ls	.L10									// -> Main decode loop body
.L9: // Post-decode
		add		x2, x2, #1
		clz		x6, x5
		str		x2, [x0, #8]
		add		x7, x7, #15
		stp		w10, w13, [x0, #56]
		stp		w16, w20, [x0, #64]
		str		w23, [x0, #72]
		cbz		x6, .L11
.L12:
		sub		x6, xzr, x6
		add		x4, x4, #1
		add		x6, x6, #8
.L11:
		clz		x9, x8
		cbz		x9, .L13
.L14:
		sub		x9, xzr, x9
		sub		x7, x7, #1
		add		x9, x9, #8
.L13:
		stp		w5, w8, [x0, #40]						// store bits
		stp		x4, x7, [x0, #24]						// store bitp
		stp		w6, w9, [x0, #48]						// store bitc
.L1: // return true
		ldr		x25, [sp, #48]
		mov		x0, #1									// return val=true
		ldp		x23, x24, [sp, #32]
		ldp		x21, x22, [sp, #16]
		ldp		x19, x20, [sp], #64
		ret		
		FUNCTION_POST_DECL(oodle_newLZ_tans_a64_kern)
		.cfi_endproc
