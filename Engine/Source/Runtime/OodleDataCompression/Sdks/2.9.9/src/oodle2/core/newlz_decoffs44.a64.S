// Copyright Epic Games, Inc. All Rights Reserved.
// This source file is licensed solely to users who have
// accepted a valid Unreal Engine license agreement 
// (see e.g., https://www.unrealengine.com/eula), and use
// of this source file is governed by such agreement.

// This file was generated by sketchy. DO NOT EDIT!
// Scheduling model: Cortex-A53
// vim:ts=4

#include "asmlib_arm_a64.inc"

		.text
		.globl MANGLE(oodle_decode_offset44_a64_kern)
		.align 4
		FUNCTION_PRE_DECL(oodle_decode_offset44_a64_kern)
MANGLE(oodle_decode_offset44_a64_kern):
		.cfi_startproc
.L0:
		ldp		x2, x3, [x0]							// offs_u8/offs_u8_end
		ldp		x4, x15, [x0, #16]						// neg_offs_s32/bitp0
		stp		x19, x20, [sp, #-80]!
		ldr		x20, [x0, #32]							// bitp1
		stp		x21, x22, [sp, #16]
		ldp		w16, w21, [x0, #40]						// bitc0/bitc1
		stp		x23, x24, [sp, #32]
		sub		x23, x3, x2
		stp		x25, x26, [sp, #48]
		subs	xzr, x23, #8							// offs_u8_end - offs_u8 >= 8
		stp		x27, x28, [sp, #64]
		sub		x24, x20, x15
		ccmp	x24, #8, #0, cs							// && bitp1 - bitp0 >= 8
		b.cc	.L2										// -> Success
.L4:
		mov		x8, #0xf0f0f0f0f0f0f0f
		sub		x3, x3, #7								// offs_u8_end -= 7
		ubfm	x8, x8, #16, #63
		sub		x20, x20, #8							// bitp[1] -= 8
		sub		x2, x2, x3								// offs_u8 -= offs_u8_end
		sub		x4, x4, #8								// neg_offs_s32 -= 2 (8B)
		mov		x9, #-4
		mov		x10, #0x7070707070707070
		orr		x11, x10, #0x202020202020202
		orr		x10, x10, #0x101010101010101
		mov		x12, #0x3c3c3c3c3c3c3c3c
		mov		x13, #0x4040404040404040
		orr		x13, x13, #0x303030303030303
		.align	4
.L5: // Main decode loop head
		ldr		x5, [x3, x2]							// grab next 8 offs_U8
		and		x16, x16, #7							// stream 0 leftover bitcnt
		ldr		x14, [x15]								// stream 0 load bits
		and		x21, x21, #7							// stream 1 leftover bitcnt
		ldr		x19, [x20]								// stream 1 load bits
		and		x6, x8, x5, lsr #4						// offs_U8 hi nibs
		prfum	#1, [x15, #71]							// stream 0 prefetch
		add		x7, x6, x10								// make hi nibs >=0x0f have MSB set
		ands	x7, x7, #0x8080808080808080				// 0x80 where large offs, 0x00 elsewhere
		rev		x14, x14								// stream 0 LE->BE
		prfum	#1, [x20, #-64]							// stream 1 prefetch
		b.ne	.L7										// -> Large offsets present
.L6: // Only small offs_U8s
		ubfm	x23, x5, #0, #7							// offs 0 U8
		ubfm	x24, x5, #8, #15						// offs 1 U8
		lslv	x27, x14, x16							// offs 0 consume bits
		adds	x2, x2, #6								// advance offs_U8 ptr (carry if done)
		sub		x25, x9, x23, lsr #4					// offs 0 neg_num_raw
		sub		x26, x9, x24, lsr #4					// offs 1 neg_num_raw
		ldr		w23, [x1, x23, lsl #2]					// offs 0 bias
		lslv	x28, x19, x21							// offs 1 consume bits
		ldr		w24, [x1, x24, lsl #2]					// offs 1 bias
		lsrv	x27, x27, x25							// offs 0 extract bits
		lsrv	x28, x28, x26							// offs 1 extract bits
		sub		w17, w23, w27, lsl #4					// offs 0 finalize offset
		sub		w22, w24, w28, lsl #4					// offs 1 finalize offset
		ubfm	x23, x5, #16, #23						// offs 2 U8
		ubfm	x24, x5, #24, #31						// offs 3 U8
		sub		x16, x16, x25							// offs 0 update bitcnt
		sub		x25, x9, x23, lsr #4					// offs 2 neg_num_raw
		sub		x21, x21, x26							// offs 1 update bitcnt
		ldr		w23, [x1, x23, lsl #2]					// offs 2 bias
		sub		x26, x9, x24, lsr #4					// offs 3 neg_num_raw
		ldr		w24, [x1, x24, lsl #2]					// offs 3 bias
		lslv	x27, x14, x16							// offs 2 consume bits
		lslv	x28, x19, x21							// offs 3 consume bits
		stp		w17, w22, [x4, #8]						// emit offset pair
		lsrv	x27, x27, x25							// offs 2 extract bits
		sub		x16, x16, x25							// offs 2 update bitcnt
		lsrv	x28, x28, x26							// offs 3 extract bits
		sub		w17, w23, w27, lsl #4					// offs 2 finalize offset
		sub		w22, w24, w28, lsl #4					// offs 3 finalize offset
		ubfm	x23, x5, #32, #39						// offs 4 U8
		ubfm	x24, x5, #40, #47						// offs 5 U8
		sub		x21, x21, x26							// offs 3 update bitcnt
		sub		x25, x9, x23, lsr #4					// offs 4 neg_num_raw
		lslv	x27, x14, x16							// offs 4 consume bits
		ldr		w23, [x1, x23, lsl #2]					// offs 4 bias
		sub		x26, x9, x24, lsr #4					// offs 5 neg_num_raw
		ldr		w24, [x1, x24, lsl #2]					// offs 5 bias
		lslv	x28, x19, x21							// offs 5 consume bits
		sub		x16, x16, x25							// offs 4 update bitcnt
		sub		x21, x21, x26							// offs 5 update bitcnt
		lsrv	x27, x27, x25							// offs 4 extract bits
		add		x15, x15, x16, lsr #3					// advance bitp0
		lsrv	x28, x28, x26							// offs 5 extract bits
		sub		x20, x20, x21, lsr #3					// advance bitp1
		ccmp	x15, x20, #2, cc						// not done and pointers not crossed
		stp		w17, w22, [x4, #16]						// emit offset pair
		sub		w17, w23, w27, lsl #4					// offs 4 finalize offset
		sub		w22, w24, w28, lsl #4					// offs 5 finalize offset
		stp		w17, w22, [x4, #24]!					// emit offset pair
		b.ls	.L5										// -> Main decode loop head
.L9:
		b		.L8										// -> Main loop done
.L7: // Large offsets present
		and		x23, x5, #0xf0f0f0f0f0f0f0f				// low nibbles of offs_U8s
		add		x24, x23, x11							// make lo nibs >=0x0e have MSB set
		ands	xzr, x24, x7							// both low nib >=0x0e and large offs?
		sub		x7, x7, x7, lsr #7						// 0x7f where large offs, 0x00 elsewhere
		sub		x6, x12, x6								// -num_raw_bits for small offs
		sub		x23, x13, x23							// adjustment for -num_raw_bits if large
		and		x23, x23, x7
		add		x6, x6, x23								// final -num_raw_bits
		mov		x25, #0x404040404040404					// shift count for small offsets
		bic		x7, x25, x7								// 0x04 where small offsets, 0x00 where large
		b.ne	.L3										// -> Fail
.L10:
		ubfm	x23, x5, #0, #7							// offs 0 U8
		ubfm	x24, x5, #8, #15						// offs 1 U8
		sbfm	x25, x6, #0, #5							// offs 0 neg_num_raw
		sbfm	x26, x6, #8, #13						// offs 1 neg_num_raw
		lslv	x27, x14, x16							// offs 0 consume bits
		ubfm	x17, x7, #0, #7							// offs 0 shift amount
		ldr		w23, [x1, x23, lsl #2]					// offs 0 bias
		lslv	x28, x19, x21							// offs 1 consume bits
		ldr		w24, [x1, x24, lsl #2]					// offs 1 bias
		ubfm	x22, x7, #8, #15						// offs 1 shift amount
		lsrv	x27, x27, x25							// offs 0 extract bits
		sub		x16, x16, x25							// offs 0 update bitcnt
		lsrv	x28, x28, x26							// offs 1 extract bits
		sub		x21, x21, x26							// offs 1 update bitcnt
		lslv	w27, w27, w17							// offs 0 shift offset field
		sub		w17, w23, w27							// offs 0 finalize offset
		lslv	w28, w28, w22							// offs 1 shift offset field
		sub		w22, w24, w28							// offs 1 finalize offset
		stp		w17, w22, [x4, #8]						// emit offset pair
		subs	xzr, x16, #35							// bitc0 too large?
		b.cs	.L11									// -> out of bits after 2 offsets
.L12:
		subs	xzr, x21, #35							// bitc1 too large?
		b.cs	.L11									// -> out of bits after 2 offsets
.L13:
		ubfm	x23, x5, #16, #23						// offs 2 U8
		ubfm	x24, x5, #24, #31						// offs 3 U8
		sbfm	x25, x6, #16, #21						// offs 2 neg_num_raw
		sbfm	x26, x6, #24, #29						// offs 3 neg_num_raw
		lslv	x27, x14, x16							// offs 2 consume bits
		ubfm	x17, x7, #16, #23						// offs 2 shift amount
		ldr		w23, [x1, x23, lsl #2]					// offs 2 bias
		lslv	x28, x19, x21							// offs 3 consume bits
		ldr		w24, [x1, x24, lsl #2]					// offs 3 bias
		ubfm	x22, x7, #24, #31						// offs 3 shift amount
		lsrv	x27, x27, x25							// offs 2 extract bits
		sub		x16, x16, x25							// offs 2 update bitcnt
		lsrv	x28, x28, x26							// offs 3 extract bits
		sub		x21, x21, x26							// offs 3 update bitcnt
		lslv	w27, w27, w17							// offs 2 shift offset field
		sub		w17, w23, w27							// offs 2 finalize offset
		lslv	w28, w28, w22							// offs 3 shift offset field
		sub		w22, w24, w28							// offs 3 finalize offset
		stp		w17, w22, [x4, #16]						// emit offset pair
		subs	xzr, x16, #35							// bitc0 too large?
		b.cs	.L15									// -> out of bits after 4 offsets
.L16:
		subs	xzr, x21, #35							// bitc1 too large?
		b.cs	.L15									// -> out of bits after 4 offsets
.L17:
		ubfm	x23, x5, #32, #39						// offs 4 U8
		ubfm	x24, x5, #40, #47						// offs 5 U8
		sbfm	x25, x6, #32, #37						// offs 4 neg_num_raw
		sbfm	x26, x6, #40, #45						// offs 5 neg_num_raw
		lslv	x27, x14, x16							// offs 4 consume bits
		sub		x16, x16, x25							// offs 4 update bitcnt
		ldr		w23, [x1, x23, lsl #2]					// offs 4 bias
		ubfm	x17, x7, #32, #39						// offs 4 shift amount
		ldr		w24, [x1, x24, lsl #2]					// offs 5 bias
		lslv	x28, x19, x21							// offs 5 consume bits
		sub		x21, x21, x26							// offs 5 update bitcnt
		ubfm	x22, x7, #40, #47						// offs 5 shift amount
		lsrv	x27, x27, x25							// offs 4 extract bits
		add		x15, x15, x16, lsr #3					// advance bitp0
		lsrv	x28, x28, x26							// offs 5 extract bits
		sub		x20, x20, x21, lsr #3					// advance bitp1
		lslv	w27, w27, w17							// offs 4 shift offset field
		sub		w17, w23, w27							// offs 4 finalize offset
		lslv	w28, w28, w22							// offs 5 shift offset field
		sub		w22, w24, w28							// offs 5 finalize offset
		stp		w17, w22, [x4, #24]!					// emit offset pair
		adds	x2, x2, #6								// advance offs_U8 ptr (carry if done)
		ccmp	x15, x20, #2, cc						// not done and pointers not crossed
		b.ls	.L5										// -> Main decode loop head
.L19:
		b		.L8										// -> Main loop done
.L11: // out of bits after 2 offsets
		add		x15, x15, x16, lsr #3					// advance bitp0
		sub		x20, x20, x21, lsr #3					// advance bitp1
		add		x4, x4, #8								// neg_offs_s32 advance
		adds	x2, x2, #2								// advance offs_U8 ptr (carry if done)
		ccmp	x15, x20, #2, cc						// not done and pointers not crossed
		b.ls	.L5										// -> Main decode loop head
.L14:
		b		.L8										// -> Main loop done
.L15: // out of bits after 4 offsets
		add		x15, x15, x16, lsr #3					// advance bitp0
		sub		x20, x20, x21, lsr #3					// advance bitp1
		add		x4, x4, #16								// neg_offs_s32 advance
		adds	x2, x2, #4								// advance offs_U8 ptr (carry if done)
		ccmp	x15, x20, #2, cc						// not done and pointers not crossed
		b.ls	.L5										// -> Main decode loop head
.L18:
		b		.L8										// -> Main loop done
.L8: // Main loop done
		add		x2, x2, x3								// make offs_u8 absolute again
		add		x4, x4, #8								// undo neg_offs_s32 bias
		add		x20, x20, #8							// undo bitp1 bias
		and		x16, x16, #7							// bitc0 final
		and		x21, x21, #7							// bitc1 final
		str		x2, [x0]
		str		x4, [x0, #16]
		stp		x15, x20, [x0, #24]						// bitp0 / bitp1
		stp		w16, w21, [x0, #40]						// bitc0 / bitc1
.L2: // Success
		mov		x0, #1
.L1:
		ldp		x27, x28, [sp, #64]
		ldp		x25, x26, [sp, #48]
		ldp		x23, x24, [sp, #32]
		ldp		x21, x22, [sp, #16]
		ldp		x19, x20, [sp], #80
		ret		
.L3: // Fail
		mov		x0, #0
		b		.L1
		FUNCTION_POST_DECL(oodle_decode_offset44_a64_kern)
		.cfi_endproc
